ExAx(P(x,x)&~P(x,x)) is an existentially quantified formula.
original queue: [({'ExAx(P(x,x)&~P(x,x))'}, set())]
fmla to expand: ExAx(P(x,x)&~P(x,x)) p_type: 4 con: 
this is a delta rule: set() fmla to work on: ExAx(P(x,x)&~P(x,x))
new branches to add to queue: [({'Ax(P(x,x)&~P(x,x))'}, {'c0'})]
queue result: [({'Ax(P(x,x)&~P(x,x))'}, {'c0'})]
fmla to expand: Ax(P(x,x)&~P(x,x)) p_type: 3 con: 
this is a gamma rule: {'Ax(P(x,x)&~P(x,x))'} fmla: Ax(P(x,x)&~P(x,x))
new branches to add to queue: [({'Ax(P(x,x)&~P(x,x))', '(P(c0,c0)&~P(c0,c0))'}, {'c0'})]
queue result: [({'Ax(P(x,x)&~P(x,x))', '(P(c0,c0)&~P(c0,c0))'}, {'c0'})]
fmla to expand: (P(c0,c0)&~P(c0,c0)) p_type: 0 con: &
This is an alpha rule: {'Ax(P(x,x)&~P(x,x))'} fmla to work on: (P(c0,c0)&~P(c0,c0))
new branches to add to queue: [({'Ax(P(x,x)&~P(x,x))', '~P(c0,c0)', 'P(c0,c0)'}, {'c0'})]
queue result: [({'Ax(P(x,x)&~P(x,x))', '~P(c0,c0)', 'P(c0,c0)'}, {'c0'})]
ExAx(P(x,x)&~P(x,x)) is not satisfiable.
